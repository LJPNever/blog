---
title: TCP
date: 2018-11-17 09:19:58
tags:
---

1. ### TCP

   <!--more-->

   ##### 三次握手

   1. 客户端向服务器端发出连接请求报文，这时候首部中的同步位SYN=1，同时选择一个初始序号seq=x。TCP规定,SYN报文段（即SYN=1的报文段）不能携带数据，但是要消耗掉一个序号，TCP客户进程进入SYN-SENT状态（同步以发送）。
   2. 服务器端收到请求报文后，想客户端发送确认报文段，SYN=1，ACK=1，确认号是ack=x+1,同时也为自己选择一个初始序号seq=y；同样此报文也不能带数据，同样消耗一个序号，TCP服务器进程进入SYN-RCVD状态（同步收到）
   3. TCP客户进程向服务器给出确认，ACK=1，确认号ack=y+1,而自己的序号seq=x+1，此时的ACK报文段可以携带数据，但如果不携带数据则不消化序号，在这种情况下，下一个数据报文段的序号仍是seq=x+1。这时TCP连接已经建立，进入ESTABLISHED(已建立连接)状态![微信图片_20181117094835](https://neverljp-1256310950.cos.ap-guangzhou.myqcloud.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20181117094835.png)

   客户端最后再发送一次确认：主要防止已失效的连接请求报文突然又传送到了B，因此产生错误。

   ##### 四次挥手

   1. 客户端把连接释放报文段首部的终止控制位FIN置1，其序号seq=u，它等于前面已传送的数据的最后一个字节的序号加1，这时候进入 FIN-WAIT-1（终止等待1）状态，FIN报文段即使不携带数据，也消耗一个序号

   2. 服务器发出确认，确认号ack=u+1,序号为v(等于服务器前面已传送的数据的最后一个字节的序号加1)，然后进入CLOSE-WAIY（关闭等待状态），此时TCP连接处于半关闭状态，即客户端没有数据要发送了，但是服务器若发数据，客户端扔要接收

      客户端收到来自服务器的确定后，就进入FIN-WAIT-2（终止等待2）状态，等待服务器发出连接释放报文

   3. 如果服务器没有要向客户端发送的数据，则通知TCP释放连接。连接释放报文段FIN=1，序号为w(在半关闭状态时服务器可能又发送一些数据)，重复上次发送的确认号ack=u+1，这时候服务器进入LAST-ACK（最后确认）状态

   4. 客户端发送确认报文，ACK置1，确认号ack=w+1,序号seq=u+1，然后进入TIME-WAIT状态，这时候，TCP连接没错释放，必须等时间等待计时器（TIME-WAIT timer）设置的时间2MSL后，才进入CLOSED状态。 MSL叫最长报文段寿命。

   ![微信图片_20181117105721](https://neverljp-1256310950.cos.ap-guangzhou.myqcloud.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20181117105721.png)

   为什么连接的时候是三次握手，关闭的时候却是四次握手？
   因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。

   为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？

   虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文

   ​

   ​**流量控制** ：指点对点通信量的控制，是端到端正的问题。流量控制所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。

   **拥塞** ：网络中某一资源的需求超过了该资源所能提供的可用部分则  对资源的需求>可用资源。

   **拥塞控制** ：防止过多的数据注入到网络中，这样可以使网络中的路由器或者链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负担。

   **拥塞控制方法** ：慢开始、拥塞避免、快重传、快恢复。

   - 慢开始：当主机开始发送数据时，拥塞窗口由小到大逐渐增大，由1开始，则cwnd=1，发送第一个报文段，当发送方接收到确认时，cwnd直接增加一倍，则一个新报文的确认（重传的不算在内）就会把拥塞窗口加1，一个传输轮次，拥塞窗口加倍。
   - 拥塞避免：让拥塞窗口缓慢增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加一，而不是慢开始加倍。拥塞避免是说把拥塞窗口控制为按线性规律增长，使网络比较容易出现拥塞
   - 快重传：可以让发送方尽早知道发生了个别报文段的丢失，快重传首先要求接收方不要等待自己发送的数据时才捎带确认，而是要立即发送确认，即使收到了失序的报文段也要立即发送对已收到的报文段的重复确认，当收到3个重复确认，则立即重传，就不会误以为发生了网络拥塞，加快了网络了吞吐量
   - 快恢复：发送方知道只是丢失了个别报文段，于是不启动慢开始，而是执行快恢复，把门限值 ssthresh=cwnd/2，cwnd=cwnd/2，并开始执行拥塞避免

