---
title: jvm虚拟机相关
date: 2019-02-27 
tags:
---

### jvm虚拟机相关

<!--more-->

#### 一、 java内存区域

![98570437ee04b3321b6ca157eb26717](E:\Never\校招准备\图片\98570437ee04b3321b6ca157eb26717.png)

- 程序计数器：一块较小的内存空间，它可以当做当前线程所执行的字节码的行号指示器  

  每条线程都需要一个独立的程序技术器，各个线程之间的计数器互不影响，独立存储，

  我们称这类内存区域为“线程私有”的区域,

  如果线程正在执行一个java 方法，这个计数器记录的就是正在执行的虚拟机字节码指令的地址

- java 虚拟机栈：也是线程私有的，它的生命周期与线程相同，每个方法在执行的同时都会创建一个

  栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接。方法出口等信息

  局部变量表（一般提及的栈内存）：存放编译期可知的各种基本数据类型、对象的引用和returnAddress(指向一条字节码指令的地址)

- 本地方法栈：为虚拟机使用到的Native方法服务（虚拟机为执行的java方法也就是字节码服务）

- java堆：被所有的线程共享的一块内存区域，唯一目的就是存放对象实例，几乎所有的对象的实例都在这里分配内存。java堆是垃圾收集器管理的主要区域也叫"GC堆"，可以细分为:新生代和老年代

- 方法区：各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。（永久代）

- 运行时常量池：方法区的一部分，存放编译期生成的各种字面量和符号引用

- 在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头、实例数据和对齐填充

  对象头包括两部分信息，第一部分用于存储对象自身的运行时数据，如哈希吗、GC分代年龄、锁状态标志、

  线程持有的锁、偏向线程的ID、偏向时间戳。  另一部分是类型指针，即对象指向它的类源数据的指针，虚拟机通过这个指针确定这个对象是哪个类的实例

#### 二、垃圾回收

- 引用计数算法：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值+1;当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能在被使用的。 （但是主流的java 虚拟机没有选择用这种方法来管理内存，主要原因是它很难解决对象间的互相循环引用问题）

- 可达性分析：一般来说，主流的语言都是用可达性分析来判定对象是否存活的。

  基本算法思想：通过“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径成为引用链，当一个对象到GC Roots没有任何引用链相连是，证明此对象不可用。

  可以作为GC Roots 的对象包括  虚拟机栈中引用的对象、方法区中类静态属性引用的对象、方法区中常量引用的对象、本地方法栈中JNI（Native方法）引用的对象

- 在可达性分析算法中不可达的对象，也不是一定被清除，一个对象死亡，至少要经历两次标记过程：如果对象在进行可行性分析后发现没有与GC Roots相连接的引用链，那会被标记并且进行一次筛选，筛选条件是是否有必要执行finalize()方法，当对象没有覆盖finalize()方法，或者finalize（）方法已经被虚拟机调用过，虚拟机将这两种情况视为“没有必要执行”。如果有必要执行，则会将这个对象放置在一个F-Queue的队列中。稍后GC 就对队列进行第二次小规模标记，如果此时对象成功连接上引用链，则会移出队列，否则将会被回收

- 永久代的主要内容是废弃常量和无用的类。废弃常量比较简单判断，对于无用的类，则需要满足以下的条件：

  1. 该类所有的实例都已经被回收，也急速java堆中不存在该类的任何实例。
  2. 加载该类的Classoader已经回收
  3. 该类对于的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

- java 堆分为新生代和老年代，在新生代，每次垃圾收集时都发现有大批对象死去，只有少量存活，就使用复制算法，只需付出少量的存活对象的复制成本就可以完成收集。在年老代，因为对象存活率高，没有额外的空间对他进行分配担保，就必须使用“标记-清理”或者“标记-整理”算法来进行回收

- 收集器 ：

  1. Parallel Scavenge: 新生代收集器，使用复制算法的收集器，是并行的多线程收集器，目的是达到一个可控制的吞吐量（吞吐量=运行用户代码的时间/（运行用户代码的时间+垃圾收集时间）），用 控制最大垃圾收集停顿时间的-XX:MaxGCPauseMillis 以及直接设置吞吐大小的 -XX: GCTimeRatio 

  2. CMS收集器： 以获取最短回收停顿时间为目标的收集器，基于“标记

     --清除算法”，分为  初始标记、并发标记、重新标记、并发清除四个步骤

  3. G1收集器：并行与并发、分代收集、空间整合、可预测的停顿

- 内存分配 : 对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配。少数情况也可能会直接分配在老年代，分配规则不是百分百固定 

- Object obj=new Object()

​        obj会作为引用类型（reference）数据保存在java 栈的本地变量表，java堆中保存该引用的实例对象，方法区：查找到此对象类型数据的地址信息

- 内存泄露：分配出去的内存没有被回收回来，由于失去了对该区域的控制，因此造成了资源浪费。

  内存溢出：指程序所需要内存超过系统所能分配的内存的上限

#### 三、类加载

- 类从被加载到虚拟机内存中开始，到卸载出内存，整个生命过程包括： 加载，验证，准备，解析，初始化，使用，准备，解析。 

  其中，加载、验证、准备、初始化、卸载这5个阶段的顺序是确定的，而解析过程阶段则不一定： 它在某些情况下可以在初始化阶段开始，这是为了支持Java 语言的运行时绑定（也称为动态绑定或晚期绑定）

- 加载：1.  通过一个类的全限定名来获取定义此类的二进制字节流  

  1. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
  2. 在内存中生成一个代表这个类的java.lang.Class对象作为方法区这个类的各种数据的访问入口

- 验证： 文件格式验证、元数据验证、字节码验证、符号引用验证。

  1. 文件格式验证：基于二进制字节流进行的，只有通过了这个阶段的验证后，字节流才会进入内存的方法区中进行存储，所以后面否认3个验证全部是基于方法区的的存储结构进行的，不会再直接操作字节流
  2. 元数据验证： 主要目的是对类的原数据信息进行语义校验，保证不存储在不符合Java语言规范的元数据信息。
  3. 字节码验证： 主要目的是通过数据流和控制流分析，确定程序语义是否合法的、符合逻辑的。
  4. 符号引用验证： 确保解析动作能正常执行

- 准备：正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配

- 解析：虚拟机将常量池内的符号引用替换为直接引用的过程

#### 虚拟机字节码执行引擎

- 执行引擎在执行Java代码的时候可能会有 解释执行（通过解释器执行） 和编译执行（通过即时编译器产生本地代码执行）两种选择，也可能两者兼备。
- 栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机的栈的栈元素。 栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。
- 一个线程的方法调用链可能会很长，很多方法都同时处于执行状态，只有位于栈顶的栈帧才是有效的，称为当前栈帧，于这个栈帧相关联的方法称为当前方法。 执行引擎运行的所有字节码指令都只针对当前栈帧进行操作。
  1. 局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。在java编译为Class文件时，就在方法的Code属性的max_locals数据项中确定的改方法所需要分配的局部变量表的最大容量







































